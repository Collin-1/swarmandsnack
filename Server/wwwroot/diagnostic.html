<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Swarm & Snack - Network Diagnostic</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: "Segoe UI", system-ui, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        text-align: center;
        margin-bottom: 30px;
      }
      .panel {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
      }
      .metric {
        display: flex;
        justify-content: space-between;
        padding: 10px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .metric:last-child {
        border-bottom: none;
      }
      .metric-label {
        font-weight: 600;
      }
      .metric-value {
        font-family: "Courier New", monospace;
        color: #4ade80;
      }
      .status-good {
        color: #4ade80;
      }
      .status-warning {
        color: #fbbf24;
      }
      .status-bad {
        color: #ef4444;
      }
      button {
        background: #4ade80;
        color: #1e293b;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
      }
      button:hover {
        background: #22c55e;
      }
      #console {
        background: #000;
        color: #0f0;
        padding: 15px;
        border-radius: 8px;
        height: 300px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 12px;
      }
      .log-line {
        margin: 2px 0;
      }
      .log-error {
        color: #ef4444;
      }
      .log-warning {
        color: #fbbf24;
      }
      .log-info {
        color: #60a5fa;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üîç Network Diagnostic Tool</h1>

      <div class="panel">
        <h2>Connection Status</h2>
        <div class="metric">
          <span class="metric-label">SignalR State:</span>
          <span class="metric-value" id="connectionState">Disconnected</span>
        </div>
        <div class="metric">
          <span class="metric-label">Room ID:</span>
          <span class="metric-value" id="roomId">-</span>
        </div>
        <div class="metric">
          <span class="metric-label">Player ID:</span>
          <span class="metric-value" id="playerId">-</span>
        </div>
      </div>

      <div class="panel">
        <h2>Performance Metrics</h2>
        <div class="metric">
          <span class="metric-label">FPS:</span>
          <span class="metric-value" id="fps">0</span>
        </div>
        <div class="metric">
          <span class="metric-label">Server Updates/sec:</span>
          <span class="metric-value" id="serverUpdates">0</span>
        </div>
        <div class="metric">
          <span class="metric-label">Estimated Latency:</span>
          <span class="metric-value" id="latency">-</span>
        </div>
        <div class="metric">
          <span class="metric-label">Input Commands Sent:</span>
          <span class="metric-value" id="inputsSent">0</span>
        </div>
      </div>

      <div class="panel">
        <h2>Input State</h2>
        <div class="metric">
          <span class="metric-label">Active Keys:</span>
          <span class="metric-value" id="activeKeys">none</span>
        </div>
        <div class="metric">
          <span class="metric-label">Current Direction:</span>
          <span class="metric-value" id="currentDirection">none</span>
        </div>
        <div class="metric">
          <span class="metric-label">Last Direction Sent:</span>
          <span class="metric-value" id="lastSent">none</span>
        </div>
      </div>

      <div class="panel">
        <h2>Position Tracking</h2>
        <div class="metric">
          <span class="metric-label">Local Position:</span>
          <span class="metric-value" id="localPos">-</span>
        </div>
        <div class="metric">
          <span class="metric-label">Server Position:</span>
          <span class="metric-value" id="serverPos">-</span>
        </div>
        <div class="metric">
          <span class="metric-label">Position Drift:</span>
          <span class="metric-value" id="drift">-</span>
        </div>
      </div>

      <div class="panel">
        <h2>Actions</h2>
        <button onclick="startTest()">Start Diagnostic Test</button>
        <button onclick="clearConsole()">Clear Console</button>
        <button onclick="location.href='/'">Back to Game</button>
      </div>

      <div class="panel">
        <h2>Console Log</h2>
        <div id="console"></div>
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@8.0.0/dist/browser/signalr.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      let connection;
      let frameCount = 0;
      let serverUpdateCount = 0;
      let inputsSent = 0;
      let lastMetricUpdate = performance.now();
      let myPlayerId = null;
      let roomId = null;
      let serverState = null;
      let myLocalPos = { x: 0, y: 0 };
      let lastInputTime = 0;
      let activeKeys = new Set();
      let currentDirection = "none";
      let lastDirectionSent = "none";

      const directionByKey = {
        ArrowUp: "up",
        ArrowDown: "down",
        ArrowLeft: "left",
        ArrowRight: "right",
        w: "up",
        a: "left",
        s: "down",
        d: "right",
      };

      function log(message, type = "info") {
        const console = document.getElementById("console");
        const line = document.createElement("div");
        line.className = `log-line log-${type}`;
        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        console.appendChild(line);
        console.scrollTop = console.scrollHeight;
      }

      function clearConsole() {
        document.getElementById("console").innerHTML = "";
      }

      function updateMetrics() {
        const now = performance.now();
        const elapsed = (now - lastMetricUpdate) / 1000;

        document.getElementById("fps").textContent = Math.round(
          frameCount / elapsed
        );
        document.getElementById("serverUpdates").textContent = Math.round(
          serverUpdateCount / elapsed
        );
        document.getElementById("inputsSent").textContent = inputsSent;
        document.getElementById("activeKeys").textContent =
          activeKeys.size > 0 ? Array.from(activeKeys).join(", ") : "none";
        document.getElementById("currentDirection").textContent =
          currentDirection;
        document.getElementById("lastSent").textContent = lastDirectionSent;
        document.getElementById("roomId").textContent = roomId || "-";
        document.getElementById("playerId").textContent = myPlayerId
          ? myPlayerId.substring(0, 8) + "..."
          : "-";

        if (serverState && myPlayerId) {
          const me = serverState.players?.find(
            (p) => p.connectionId === myPlayerId
          );
          if (me?.leader) {
            document.getElementById(
              "serverPos"
            ).textContent = `(${me.leader.x.toFixed(0)}, ${me.leader.y.toFixed(
              0
            )})`;

            const dx = myLocalPos.x - me.leader.x;
            const dy = myLocalPos.y - me.leader.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const driftEl = document.getElementById("drift");
            driftEl.textContent = `${dist.toFixed(1)}px`;
            driftEl.className =
              dist > 50
                ? "metric-value status-bad"
                : dist > 20
                ? "metric-value status-warning"
                : "metric-value status-good";
          }
        }

        document.getElementById(
          "localPos"
        ).textContent = `(${myLocalPos.x.toFixed(0)}, ${myLocalPos.y.toFixed(
          0
        )})`;

        frameCount = 0;
        serverUpdateCount = 0;
        lastMetricUpdate = now;
      }

      async function startTest() {
        log("Starting diagnostic test...", "info");

        connection = new signalR.HubConnectionBuilder()
          .withUrl("/gamehub", {
            transport: signalR.HttpTransportType.WebSockets,
          })
          .withAutomaticReconnect()
          .configureLogging(signalR.LogLevel.Information)
          .build();

        connection.on("GameCreated", (payload) => {
          roomId = payload.roomId;
          myPlayerId = payload.player.playerId;
          log(`Game created! Room: ${roomId}`, "info");
        });

        connection.on("GameStateUpdated", (payload) => {
          serverUpdateCount++;
          serverState = payload;

          if (!roomId) {
            roomId = payload.roomId;
          }

          if (serverUpdateCount === 1) {
            log("First state update received", "info");
          } else if (serverUpdateCount % 100 === 0) {
            log(`${serverUpdateCount} state updates received`, "info");
          }
        });

        connection.onreconnecting(() => {
          log("SignalR reconnecting...", "warning");
          document.getElementById("connectionState").textContent =
            "Reconnecting";
        });

        connection.onreconnected(() => {
          log("SignalR reconnected", "info");
          document.getElementById("connectionState").textContent = "Connected";
        });

        connection.onclose(() => {
          log("SignalR connection closed", "error");
          document.getElementById("connectionState").textContent =
            "Disconnected";
        });

        try {
          await connection.start();
          log("SignalR connected successfully", "info");
          document.getElementById("connectionState").textContent = "Connected";

          await connection.invoke("CreateGame", "Diagnostic Test");
          log("Creating test room...", "info");

          // Start metric updates
          setInterval(updateMetrics, 1000);

          // Start animation loop
          requestAnimationFrame(diagnosticLoop);

          log("Test started. Press arrow keys or WASD to test input", "info");
        } catch (err) {
          log(`Connection failed: ${err}`, "error");
        }
      }

      function diagnosticLoop() {
        frameCount++;

        // Simulate local position update (simplified)
        const speed = 160;
        const deltaSeconds = 1 / 60;
        const dir = getDirectionVector(currentDirection);
        myLocalPos.x += dir.x * speed * deltaSeconds;
        myLocalPos.y += dir.y * speed * deltaSeconds;

        requestAnimationFrame(diagnosticLoop);
      }

      function getDirectionVector(direction) {
        switch (direction) {
          case "up":
            return { x: 0, y: -1 };
          case "down":
            return { x: 0, y: 1 };
          case "left":
            return { x: -1, y: 0 };
          case "right":
            return { x: 1, y: 0 };
          default:
            return { x: 0, y: 0 };
        }
      }

      function resolveDirection() {
        if (activeKeys.size === 0) return "none";
        return Array.from(activeKeys)[activeKeys.size - 1];
      }

      function sendDirection(direction) {
        if (
          !connection ||
          connection.state !== signalR.HubConnectionState.Connected
        ) {
          log("Cannot send direction: not connected", "warning");
          return;
        }

        if (direction === lastDirectionSent) {
          return;
        }

        inputsSent++;
        const now = performance.now();
        const timeSinceLastInput = now - lastInputTime;
        log(
          `Sending direction: ${direction} (${timeSinceLastInput.toFixed(
            0
          )}ms since last)`,
          "info"
        );
        lastInputTime = now;

        connection
          .invoke("Move", direction)
          .then(() => {
            lastDirectionSent = direction;
          })
          .catch((err) => {
            log(`Move failed: ${err}`, "error");
          });
      }

      window.addEventListener("keydown", (e) => {
        const direction = directionByKey[e.key];
        if (!direction) return;

        e.preventDefault();
        activeKeys.add(direction);
        const resolved = resolveDirection();
        currentDirection = resolved;
        sendDirection(resolved);
      });

      window.addEventListener("keyup", (e) => {
        const direction = directionByKey[e.key];
        if (!direction) return;

        e.preventDefault();
        activeKeys.delete(direction);
        const resolved = resolveDirection();
        currentDirection = resolved;
        sendDirection(resolved);
      });

      log(
        'Diagnostic tool ready. Click "Start Diagnostic Test" to begin.',
        "info"
      );
    </script>
  </body>
</html>
